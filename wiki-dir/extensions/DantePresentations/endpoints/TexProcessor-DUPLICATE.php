<?php

require_once (__DIR__."/../config.php");
require_once ("polyfill.php");                       // include some PHP polyfill stuff
 

class TeXProcessor {
  
public static $makeFileStack= array();  
  
/** purges the parser cache of a page with given title */
public static function purgeByTitle ($titleText) {
  $title   = Title::newFromText($titleText);
  $article = new Article($parentTitle);
  $article->mTitle->invalidateCache();
}  


/** Generate Latex and Pdflatex precompiled versions of the file $name and place them into the respective format directories. */
public static function precompile ($name) {
  $VERBOSE = true;
  $TEMPLATE_PATH = TEMPLATE_PATH; $LATEX_FORMAT_PATH = LATEX_FORMAT_PATH; $PDFLATEX_FORMAT_PATH = PDFLATEX_FORMAT_PATH;
  
  self::ensureEnvironment();
  if ($VERBOSE) {self::debugLog ("TeXProcessor::precompile: Tex2Pdf sees the following environment: \n".print_r (getenv(), true) );}
  
  self::cleanUpAll();  // clean up ALL existing /tmp files since all pages have to be re-done
  
  // clear the format files to ensure that we do not continue to use an old format when a compilation fails and produces no new format file
  unlink ("$LATEX_FORMAT_PATH/$name.fmt");      unlink ("$LATEX_FORMAT_PATH/$name.fls");      unlink ("$LATEX_FORMAT_PATH/$name.log");
  unlink ("$PDFLATEX_FORMAT_PATH/$name.fmt");   unlink ("$PDFLATEX_FORMAT_PATH/$name.fls");   unlink ("$PDFLATEX_FORMAT_PATH/$name.log");
  
  $cmd =  PREFIX_ERROR . " latex  --interaction=nonstopmode  -file-line-error-style  -ini -recorder -output-directory=$LATEX_FORMAT_PATH \"&latex $LATEX_FORMAT_PATH/$name.tex\dump\" "; 
  if ($VERBOSE) { self::debugLog("TeXProcessor::precompile: will now execute latex precompile command ".$cmd."\n"); }  
  $output1 = null; $retVal1 = null;  
  exec ( $cmd, $output1, $retVal1 ); 
  if ($VERBOSE) { self::debugLog("TeXProcessor::precompile: latex command returned: $retVal1 and output: " . print_r ($output1, true)); }
  
  $cmd = PREFIX_ERROR . " pdflatex  --interaction=nonstopmode  -file-line-error-style  -ini -recorder -output-directory=$PDFLATEX_FORMAT_PATH \"&pdflatex $PDFLATEX_FORMAT_PATH/$name.tex\dump\" ";    
  if ($VERBOSE) { self::debugLog("TeXProcessor::precompile: will now execute pdflatex precompile command ".$cmd."\n"); }
  $output2 = null; $retVal2 = null; 
  exec ( $cmd, $output2, $retVal2 ); 
  if ($VERBOSE) {self::debugLog("TeXProcessor::precompile: pdflatex command returned: $retVal2 and output: " . print_r ($output2, true)); } 

  if ($retVal1 != 0 || $retVal2 != 0) {
    return print_r($output1, true) . print_r ($output2, true);
  }
  else {return false;}
}


// testing function during development to see how long the individual production chains run
public static function timeTest ($in, $tag) {
  self::debugLog ("------------------- STARTING TIME TEST --------------------------\n");
  
  $hash = self::generateTex ($in, $tag, "");     // generates $hash.tex
  self::generateTex ($in, $tag, "pc_latex");     // generates $hash_pc_latex.tex
  self::generateTex ($in, $tag, "pc_pdflatex");  // generates $hash_pc_pdflatex.tex

//  self::Tex2DviLatex  ($hash, "");
//  self::Tex2DviLatex  ($hash, "_pc_latex");
  
  self::Tex2Pdf       ($hash, "_pc_pdflatex", "timetest");
  
  // self::Tex2DviLatex  ($hash, "_pc_pdflatex");    // NON working combination 
//  self::Tex2DviPdflatex  ($hash, "");
//  self::Tex2DviPdflatex  ($hash, "_pc_latex");
//  self::Tex2DviPdflatex  ($hash, "_pc_pdflatex");    
 // self::generatePdfBboxGS ($hash);  
//  self::generateNodePngHtml ($hash, self::SCALE (1200, 15));
//  self::Dvi2Png   ($hash, self::DPI(800, 15), 1.5);     
//  self::Pdf2PngMT ($hash, self::DPI(800, 15), "_pc_pdflatex", "_mt" );     
    
  self::Pdf2PngHtmlMT ($hash, self::SCALE(800, 15), "_pc_pdflatex", "_pc_pdflatex" ); 
  
  //self::Pdf2SvgMT ($hash, self::DPI(800, 15) );       
  //self::Pdf2PngGS ($hash, self::DPI(800, 15) );     
  self::debugLog ("------------------- COMPLETED TIME TEST --------------------------\n");
}



/** return an html structure generated by our custom tagged content
 *  $in:     contents between the line containing the opening xml tag and the closing xml tag; not containing the newline with which the opening line is terminated
 *  $ar:     array of attribute values which were found in the xml tag
 *  $tag:    name of the xml tag used (eg: amstex, m, math, beamer or whatever we have implemented)
 * 
 * lazyRender is called by the Mediawiki parser and obtains the entire text which comes directly after the <amsmath> or similar tag.
* 
* 
* CACHE: NOTE: This function is not called upon every page display due to possible interference with the cache system.
*        NOTE: We can purge the cache and then it WILL be called.
* 
* php purgeList.php --purge --all, for MW > 1.21, and php purgeList.php --all-namespaces for MW >= 1.34.
* 
*  The function is activated upon an edit/save of a wiki page.
*/

public static function lazyRender ($in, $ar, $tag, $parser) {
  global $wgServer, $wgScriptPath, $wgOut;  global $wgTopDante;
  
  $CACHE_PATH = CACHE_PATH;
  $VERBOSE    = true;

try {
  

  if (property_exists ($wgTopDante, "hookInvokes") ) { $wgTopDante->hookInvokes++; 
    if ($VERBOSE) {self::debugLog ("lazyRender sees hookInvokes=".$wgTopDante->hookInvokes."\n") ;}
  }
  else { $wgTopDante->hookInvokes = 0;}


  $timestamp = strftime ("%d.%m.%Y at %H:%M:%S", time() );         // want a timestamp in the img tag on when the page was translated for debugging purposes
  if ($VERBOSE) {$startTime = microtime (true); self::debugLog ("lazyRender called at: $timestamp for pageTitle " . $parser->getTitle()."  Page starts with: ". trim(substr(trim($in), 0, 20)) . "\n");}
  
  self::ensureCacheDirectory ();     
  self::ensureEnvironment ();       // TODO: move up and out - optimization

  // IMPORTANT: for consistency with the Javascript pickup and parse mechanism we need to remove everything up to and including the first newline - we MUST get the same hash value in both cases and for identical rendering this must be ignored by latex
  $startingAt = strpos ($in, "\n");                               // find the first \n
  $in         = substr ($in, $startingAt+1);                      // and jump over it
  $hash       = self::generateTex ($in, $tag, "pc_pdflatex");     // generate $hash_pc_pdflatex.tex and obtain hash of raw LaTeX source located in Mediawiki
  
  // accumulate in the parser connected output object of that page an array with all the hash values used on this page; do so for cleaning up hashs which become stale
  $usedHashs = unserialize ( $parser->getOutput()->getProperty( 'ParsifalHashsUsed' ) );
  if ( strcmp (gettype ($usedHashs), "array") != 0 ) {$usedHashs = array();}  // if not found, initialize in empty array()
  array_push ($usedHashs, $hash);
  $parser->getOutput()->setProperty( 'ParsifalHashsUsed', serialize ($usedHashs));
  
  $texPath        = $CACHE_PATH.$hash."_pc_pdflatex.tex"; 
  $annotationPath = $CACHE_PATH.$hash."_pc_pdflatex_final.html";                         // the local php file path under which we should find the annotations in form of a (partial) html file
  $finalImgUrl    = $wgServer.$wgScriptPath.CACHE_URL.$hash."_pc_pdflatex_final.png";
  $finalImgPath   = $CACHE_PATH.$hash."_pc_pdflatex_final.png";  

  if ($VERBOSE) {self::debugLog ("lazyRender will now Tex2PDF $hash\n") ;}
  
  if (!file_exists ($CACHE_PATH . $hash . "_pc_pdflatex.pdf" ))       { 
    if ($VERBOSE) {self::debugLog ("lazyRender starting Tex2Pdf now for: ".$hash);}
    self::Tex2Pdf ($hash, "_pc_pdflatex", "lazyrender");                                             }
  if (!file_exists ($finalImgPath) || !file_exists ($annotationPath)) { self::Pdf2PngHtmlMT ($hash, self::SCALE(BASIC_SIZE, 15), "_pc_pdflatex", "_pc_pdflatex_final" ); }

  // TeXProcessor::manuBoth ( $hash, "_pc_pdflatex", "lazyrender", $hash, self::SCALE(BASIC_SIZE, 15), "_pc_pdflatex", "_pc_pdflatex_final");  // is not yet really working smoothly
  
   // same resolution ?? /////////////////////////////////////////////////////// TODO add theming and resolutions
      
  // self::timeTest ($in, $tag);  // TRIGGERING a TIMING TEST: ONLY DURING DEVELOPMENT, kicks off all possible ways to produce resources

  // the files we will finally use when saving are put into 0660 mode as marker that they are available for consumption; the preview files remain at 0600
  if (file_exists ($annotationPath) )  { chmod ($annotationPath, 0660); }  
  if (file_exists ($finalImgPath)   )  { chmod ($finalImgPath,   0660); }
  
  //  $arText = json_encode($ar);    // $ar contains an array of attribute values of the xml tag; convert it to json form

  // We need a width and height in the img tag to assist the browser to a more smooth and flicker-less reflow.
  // The width MUST be equal to the width of the image (or else the browser must rescale the image, which BLURS the image and takes TIME)
  if (file_exists ( $finalImgPath ) ) { 
    $ims = @getimagesize ( $finalImgPath ); 
    if ($ims) {$width = $ims[0]; $height = $ims[1];} else {throw new ErrorException ("Looks like $finalImgPath is not yet ready");}
  } else {throw new ErrorException ("Did not find the image $finalImgPath for purposes of getimagesize");}

  // onload:    delay showing the image until it is completely loaded (prevents user from seeing half of an image during the load process)
  // onerror:   kickoff generation of image should it be missing (reason could be: file was (incorrectly) deleted on the server)
 
  $naming = ( array_key_exists ("n", $ar) ? "data-name='".$ar["n"]."' " : "");
  $title = $parser->getTitle ();    // get title of current page (also need this below !   // CAVE:  WILL  need different call,  getPage()   from 1.37 on !!!!!!!!!!!!!!!!!!!!

///// WHAT is THIS ?????
/////////////// TODO: ??????????????? We must check / ensure that this name has not yet been used already on this page with this name
  if (array_key_exists ("n", $ar)) { // if tag has a name then produce a further copy of the page  
    TeXProcessor::$makeFileStack[$title."/".$ar["n"]] = "<$tag>\n$in\n</$tag>"; 
  }
   
  $imgResult    = "<img width='$width' height='$height' $naming src='$finalImgUrl' onerror='window.imageIsMissing(\"$title\",\"$hash\")' onload='window.showImage(event.target,\"$hash\");'  data-timestamp='$timestamp'  id='$hash' data-hash='$hash'  class='texImage' alt='Image is being processed, please wait, will fault it in automatically as soon as it is ready'></img>";

  if (file_exists ($annotationPath)) { $annoResult = ("<div class='annoLayer'>".file_get_contents ($annotationPath)."</div>"); }   
  $renderResult = $imgResult . $annoResult;

  $ret =  self::htmlDecorator ($renderResult, $ar, $tag);                   // add some decoration at the HTML level
  
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime;  self::debugLog ("lazyRender: COMPLETED. TOTAL RUNTIME=$duration \n");}
} catch (Exception $e) { $msg = $ret = $e->getMessage();  $ret = "<b>$msg</b><br>".$e->getTraceAsString();}  // in case of exception, build a suitable error element 
  return $ret;
}
  
  
  
/** Given the <img> tag, produce the HTML decoration for the final content element. 
 *  $img:  string with img html text
 *  $ar:   array of attribute values which were found in the xml tag and which control the decoration process
 *  $tag:  name of the xml tag used (eg: amstex, m, math, beamer or whatever we have implemented)
 *
 */  
public static function htmlDecorator ($img, $ar, $tag) {
   // TODO: missing: add error indication and log file links 
  
  if (array_key_exists ("n",$ar)) {
  $named = "<span class='named' title='Copy name to clipboard &#009;".$ar["n"]."' data-name='justatestasd' onclick='window.copyToClip(event);'>&#x1f4cb;</span>";
} else {$named="";}
  
  $img = "<div class='parsifalContainer'>".$img."$named</div>";  // always wrap in parsifalContainer which by the position:relative is responsible for proper positioning of annotation and image
  
  $size = BASIC_SIZE + 10;                                 // provide a bit slack space for the decoration of the collapsing area
  // implement the o attribute (collapsing with a button, possibly showing a specific title, initially open)
  if (array_key_exists ("o", $ar) ) {     
    $style = "display:block;width:".$size."px;";         
     return   "<span onclick='toggleNext(event);' title='Toggle collapse state' class='collapseButton'>". ( empty($ar["o"]) ? "Collapsed" : $ar["o"] ) ."</span><div style='$style' class='collapseResult'>".$img."</div>";  
  }
  
  // implement the c attribute (uncollapsing with a button, possibly showing a specific title, initially collapsed)
  if (array_key_exists ("c", $ar) ) {
      $style = "display:none;width:".$size."px;";      
    if ( empty($ar["c"]) ) { return   "<span onclick='toggleNext(event);' title='Toggle collapse state' class='collapseButton'>Collapsed Content</span><div style='$style' class='collapseResult'>".$img."</div>";      }
    else                   { return   "<span onclick='toggleNext(event);' title='Toggle collapse state' class='collapseButton'>".$ar['c']."</span><div onclick='toggleImg(event);' style='$style' class='collapseResult'>".$img."</div><span style='clear:left;'></span>";  }
  }
  
  if (count ($ar) > 0) {
    // implement the o-attribute
    // NOTE: implement this as server-side choice in the interest of better speed (no runtime choice but compiletime choice) and page control by author
    foreach ( $ar as $key => $val ) {
      $att = substr ($key, 2);                // remove the c- and the o- prefix  
      self::debugLog ("FIRST ARGUMENT IS: " . print_r ($att, true) . "\n");
      if (!$att) {continue;}
      $name  = (array_key_exists ($att, ATT2NAME)  ? ATT2NAME[$att]  : ATT_DEFAULT_NAME);
      $styleBtn = (array_key_exists ($att, ATT2STYLE_SPEC) ? ATT2STYLE_SPEC[$att] : ATT_DEFAULT_STYLE_SPEC ); 
      if (str_starts_with ($key, "o-") ) {               // attribute  o-*
        $style = "display:block;width:".$size."px;";
        return   "<span onclick='toggleNext(event);' title='Toggle visibility' class='collapseButton' style='$styleBtn'>$name</span><div onclick='toggleImg(event);' style='$style' class='collapseResult'>".$img."</div>";
      }
      if (str_starts_with ($key, "c-") ) {              // attribute c-*
        $style = "display:none;width:".$size."px;";  
        return   "<span onclick='toggleNext(event);' title='Toggle visibility' class='collapseButton' style='$styleBtn'>$name</span><div onclick='toggleImg(event);' style='$style' class='collapseResult'>".$img."</div>";
       }
     } // foreach
  }
  
  return $img;
}  
  
  
/////////////////////////// WHAT IS THIS MEANT FOR ?????
// create new page in Help: namespace for the named tag elements
  public static function createNewPage () {
    self::debugLog ("*** createNewPage: entered. Stack size is " . count (TeXProcessor::$makeFileStack) . " \n");
    if ( count(TeXProcessor::$makeFileStack) == 0) {self::debugLog ("*** createNewPage: empty stack \n");  return;}
    self::debugLog ("*** createNewPage: making new page \n");
    
    foreach (TeXProcessor::$makeFileStack as $key => $val) {
      self::debugLog ("*** createNewPage: making new page NOW with key $key and content $val \n");
      $newTitle = Title::newFromText($key, NS_HELP );
      if ( !is_null( $newTitle ) /* && !$newTitle->isKnown() && $newTitle->canExist() */ ){
        $newPage = new WikiPage( $newTitle );
        
        $val = "<span style='color:red;font-family:mono;font-size:20pt;font-weight:bold;'>This is an auto-generated page. Do not edit!</span>" . $val;
        
        $newContent = ContentHandler::makeContent($val, $newTitle );
        $newPage->doEditContent( $newContent, 'Autogenerated file' );
      }
      else {
         self::debugLog ("createNewPage: Could not make new page \n");
      }
    }
    self::debugLog ("*** createNewPage: loop flag is now SET TO FALSE \n");
    TeXProcessor::$makeFileStack = 0;  // clear stack, we are done
  }
  
  
  
  
  // NOTE: TeXProcessor::renderPreviewPNG and _base64 and called functions can be called from the web and from mediawiki and hence must not depend on any mediawiki global variables - all configuration done in config.php


/* SCALING CALCULATION: Given the number of pixels we have available in the presentation IMG, what is the required DPI value to be used in divpng?
   
   We get 591 pixel width for 100 dpi for a document of Latex width 15cm
   15cm = 5,90551 inches  in resolution 100 dpi we get 590,551 dots and with rounding 591 as width 
     
     Pixels = dpi * LatexWidthInCm * cmToInches  
     dpi = availablePixelWidth / (LatexWidthInCm * cmToInches) = 2.54 * availablePixelWidth / LatexWidthInCm

   We have $pixels many pixels available in the HTML area of our image.
   The text document is 

*/
public static function DPI ($pixels, $textWidthCm) { return floor (2.54 * $pixels / $textWidthCm); }


/* Scaling calculation: Given the number of pixels we have available in the presentation IMG, what is the required scale value to be used in pdf.js rendering?
    
  We get 1079 pixel width when we compile a 15cm width Latex document with a scale of 2.54.
  We get 424  pixel width when we compile a 15cm width Latex document with a scale of 1.00
  
  In scale = 1.00 we get: Per cm Latex: 28 pixel.  Per inch Latex: 72 pixel 
  
  LatexWidthInCm [cm] of  latex are  LatexWidthInCm * cmToInches [inches] are LatexWidthInCm * cmToInches * 72 [pixel] = LatexWidthInCm *72 / 2.54  [pixels]

  scale = 2.54 * pixels / ( textWidthCm * 72 )
*/


public static function SCALE ($pixels, $textWidthCm) {return (2.54 * $pixels) / (1.0 * $textWidthCm * 72);}


private static function texRefreshEndpoint ($title) {
  
}




/* ensures that PHP has the right concept required for the TeX processing environment */
private static function ensureEnvironment () {
  // set the environment variables as specified in the TeXLive installer
  putenv ("TEXDIR=".TEXDIR); 
  putenv ("TEXMFLOCAL=".TEXMFLOCAL);
  putenv ("TEXMFSYSVAR=".TEXMFSYSVAR); 
  putenv ("TEXMFSYSCONFIG=".TEXMFSYSCONFIG); 
  putenv ("TEXMFVAR=".TEXMFVAR);
  putenv ("TEXMFCONFIG=".TEXMFCONFIG);    
  putenv ("TEXMFHOME=".TEXMFHOME);      

  // need PATH to tex binaries and to standard OS binaries such as sed and others for font generation scripts
  putenv ("PATH=".PATH);
  putenv ("HOME=".HOME);
  
  // want to access local style and packges files from a local directory
  putenv ("TEXINPUTS=".TEXINPUTS);
}


public static function ensureCacheDirectory () {
  $CACHE_PATH = CACHE_PATH;
  // TeXProcessor::debugLog ("ensuring existence of cache directory: $CACHE_PATH \n");
  if ( !file_exists ($CACHE_PATH) ) {
    TeXProcessor::debugLog( "TeXProcessor::ensureCacheDirectory: detected a missing cache directory; trying to construct: $CACHE_PATH \n");     
    $retVal = mkdir ($CACHE_PATH, 0755); 
    TeXProcessor::debugLog( "  mkdir returned $retVal \n");
  }
}


// called from endpoints/tex-preview.php
public static function texPreviewEndpoint () {
  $VERBOSE    = false; 
  $CACHE_PATH = CACHE_PATH;
  
  TeXProcessor::ensureCacheDirectory ();                        // TODO: all the time ??? 
  TeXProcessor::ensureEnvironment ();  
  umask (0077);                                                 // preview files should be generated at 600 permission
  
  $body = file_get_contents("php://input");                     // get the input; here: the raw body from the request
  $body = base64_decode ($body);                                // in an earlier version we used, unsuccessfully, some conversion, as in:   $body = iconv("UTF-8", "ISO-8859-1//TRANSLIT", $body); 
  
  // obtain and sanitize further parameter values from the http header
  $tag                  = $_SERVER['HTTP_X_PARSIFAL_TAG'];
  $paraText             = $_SERVER['HTTP_X_PARSIFAL_PARA'];   
  $availablePixelWidth  = $_SERVER['HTTP_X_PARSIFAL_AVAILABLE_PIXEL_WIDTH'];     if (! isset ($availablePixelWidth)) { $availablePixelWidth = 600; }
  $widthLatexCm         =  TAG2WIDTHinCM[$tag];                                  if (! isset ($widthLatexCm))        { $widthLatexCm = 15; }  
     
  if ($VERBOSE) {self::debugLog ("texPreviewEndpoint: sees tag: " . $tag . " widthLatexCm: ". $widthLatexCm . "  availablePixelWidth: ". $availablePixelWidth . " \n");}
  
  try {
    $hash = "NOT YET SET, CRASHED TOO EARLY";                                      // we want a sane value in case self::generateTex crashes for some reason
    $hash = self::generateTex ($body, $tag, "pc_pdflatex");                        // prepare for a precompiled pdflatex run
    $retval = self::Tex2Pdf ($hash, "_pc_pdflatex", "endpoint");                   // do a precompiled pdflatex run
    
    $para = json_decode ( $paraText, true);                  // decode parameter object (which we might get from the endpoint)
    $dpi =  self::DPI ($availablePixelWidth, $widthLatexCm); if ( array_key_exists ("dpi", $para) )   { $dpi = $para["dpi"]; if ($VERBOSE) {self::debugLog ("texPreviewEndpoint: finds dpi override = ".$dpi. "\n");} }  // DPI parameter
    $gamma = 1.5; if ( array_key_exists ("gamma", $para) ) { $gamma = $para["gamma"];  if ($VERBOSE) {self::debugLog ("texPreviewEndpoint: finds gamma override = ".$gamma. "\n");} }                               // GAMMA parameter
        
    $name =  $CACHE_PATH . $hash."_pc_pdflatex.png";
    $scale = self::SCALE($availablePixelWidth, $widthLatexCm); 
    self::Pdf2PngHtmlMT ($hash, $scale, "_pc_pdflatex", "_pc_pdflatex" );          // png must be redone since scale depends on width of preview area
     
//// TODO: currently it looks like we do not send the annotations and html portion for the preview
//     this might be ok but why do we then compute them??
//     and: when load is low we could also kick off generation of the final version

    // send the result to the client
    if ($VERBOSE) {self::debugLog ("texPreviewEndpoint: will now send $name to client, dpi=$dpi, gamma=$gamma \n");}
    if (filesize($name) == 0) { throw new Exception ("texPreviewEndpoint sent a PNG file of size zero. filename: " . $name); }
    $fp = fopen($name, 'rb');
    if ($fp == FALSE)         { throw new Exception ("texPreviewEndpoint could not open PNG file " . $name ); }

   if ($VERBOSE) {self::debugLog ("texPreviewEndpoint: in try block before HEADER \n");}

    // add some headers to the response to support debugging and further handling
    header ("X-Latex-Hash:".$hash);  
    header ("X-Parsifal-Width-Latex-Cm-Was:".$widthLatexCm);
    header ("X-Parsifal-Available-Pixel_Width-Was:".$availablePixelWidth);
    header ("X-Parsifal-Gamma-Used:".$gamma);
    header ("X-Parsifal-Scale-Used:".$gamma);  
    
    if ($retval == 0) { header ("X-Parsifal-Error:None"); }
    else              { header ("X-Parsifal-Error:Soft"); 
            $insideError  = false;
            $errorDetails = "";
            foreach ($retval as $infoline) {
              if ( strcmp ($infoline, ERROR_PARSER_START) == 0) {$insideError = true; continue;}
              if ( strcmp ($infoline, ERROR_PARSER_END  ) == 0) {$insideError = false; continue;}
              if ($insideError) {
                $hpos = strpos ($infoline, $hash);
                if ($hpos) { $infoline = substr ($infoline, $hpos + 48); }
                $errorDetails .= $infoline;}
            }
      
            $errorDetails = str_replace ( array ("\r", "\n", "\"",  ":"), "", $errorDetails); 
      
                        header ("X-Parsifal-ErrorDetails:".$errorDetails);  // only: if we want to send more detailed errors to client alread in case of soft errors   
                      }  

    header("Content-type:image/png");  header("Content-Length: " . filesize($name));  // set MANDATORY http reply headers
    fpassthru($fp); 
    fclose ($fp);
  } catch (Exception $ex) { 
    self::renderError ("texPreviewEndpoint Error: ", $ex, $hash); 
  }
  if ($VERBOSE) {self::debugLog ("texPreviewEndpoint: returns from call for " . $tag . " widthLatexCm: ". $widthLatexCm . "  availablePixelWidth: ". $availablePixelWidth . " \n");}
}



// return exception and error information; use as error handler in all client render methods; provides text, recipient decides on wrapping html etc.
// $add: additional info,    $ex: exception thrown   $nameBase additional info which hash etc was affected
static function renderError ($add, $ex, $nameBase) {
  $txt = $ex->getMessage()."\nhash=$nameBase\n".$ex->getTraceAsString();  
  header ("X-Latex-Hash:".$nameBase); 
  header ("X-Parsifal-Error:Hard"); 
  header ("Content-type:text/html"); 
  header ("Content-Length: " .strlen( $txt) );
  echo $txt;
  self::debugLog ("renderError called: " . $add. "  " . $ex->getMessage() . "\n");
}  
  
// clean up all files belonging to a specific hash  
static function cleanUp ($hash) {
  $CACHE_PATH = CACHE_PATH;     
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.tex");  
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.aux");    
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.aux");    
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.log");   
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.out");   
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.png");   
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.pdf");   
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.html");  
  unlink ( "$CACHE_PATH$hash_pc_pdflatex.mrk");                  
}
   
  
// clean up all files in $CACHE_PATH, independently of the hash
static function cleanUpAll () {
  $CACHE_PATH = CACHE_PATH;
  $VERBOSE = true;
  if ($VERBOSE) {self::debugLog ("cleanUpAll called \n");}
  $files = glob ( $CACHE_PATH."*_pc_pdflatex.tex");  $count = count ( $files ); if ($VERBOSE) {self::debugLog ("found $count _pc_pdflatex.tex files for deletion \n");}  array_map ("unlink", $files);
  $files = glob ( $CACHE_PATH."*_pc_pdflatex.aux");  $count = count ( $files ); if ($VERBOSE) {self::debugLog ("found $count _pc_pdflatex.aux files for deletion \n");}  array_map ("unlink", $files);  
  $files = glob ( $CACHE_PATH."*_pc_pdflatex.log");  $count = count ( $files ); if ($VERBOSE) {self::debugLog ("found $count _pc_pdflatex.log files for deletion \n");}  array_map ("unlink", $files);  
  $files = glob ( $CACHE_PATH."*_pc_pdflatex.out");  $count = count ( $files ); if ($VERBOSE) {self::debugLog ("found $count _pc_pdflatex.out files for deletion \n");}  array_map ("unlink", $files);  
  $files = glob ( $CACHE_PATH."*_pc_pdflatex.png");  $count = count ( $files ); if ($VERBOSE) {self::debugLog ("found $count _pc_pdflatex.png files for deletion \n");}  array_map ("unlink", $files);  
  $files = glob ( $CACHE_PATH."*_pc_pdflatex.pdf");  $count = count ( $files ); if ($VERBOSE) {self::debugLog ("found $count _pc_pdflatex.pdf files for deletion \n");}  array_map ("unlink", $files);  
  $files = glob ( $CACHE_PATH."*_pc_pdflatex.html"); $count = count ( $files ); if ($VERBOSE) {self::debugLog ("found $count _pc_pdflatex.html files for deletion \n");}  array_map ("unlink", $files);  
  $files = glob ( $CACHE_PATH."*_pc_pdflatex.mrk");  $count = count ( $files ); if ($VERBOSE) {self::debugLog ("found $count _pc_pdflatex.mrk files for deletion \n");}  array_map ("unlink", $files);              
}
  

  
  static function debugLog ($text) {
    if($tmpFile = fopen( LOG_PATH, 'a')) {fwrite($tmpFile, $text);  fclose($tmpFile);} 
    else {throw new Exception ("debugLog in TexProcessor could not log"); }
  }
  
  
  static function errorLog ($text) {
    if($tmpFile = fopen( ERR_PATH, 'a')) {fwrite($tmpFile, $text);  fclose($tmpFile);} 
    else {throw new Exception ("errorLog in TexProcessor could not log"); }
  }  

  
  
/** determine hash code of content and if no TeX file is there, build one
 *    $in     string containing latex content
 *    $tag    string with tagname of xml tag /
 *    $mode   the mode tag, i.e.  "" or "pc_latex" or "pc_pdflatex"
 */  
private static function generateTex ($rawContent, $tag, $mode) {
  $VERBOSE       = true;
  $CACHE_PATH    = CACHE_PATH;
  $TEMPLATE_PATH = TEMPLATE_PATH;  $LATEX_FORMAT_PATH = LATEX_FORMAT_PATH;  $PDFLATEX_FORMAT_PATH = PDFLATEX_FORMAT_PATH;
  
  $hash = md5($rawContent);                            // derive a unique file name - only from the hash of the INPUT (not of the template or attributes or tags used)

  switch ($mode) {
    case "pc_latex":      $fmt="$LATEX_FORMAT_PATH$tag";     $resultFile = "$CACHE_PATH{$hash}_$mode.tex";  ASSERT_FILE ("$fmt.fmt"); 
      $template = "%&$fmt\n".PC_LATEX_ADDON[$tag];     break;
    case "pc_pdflatex":   $fmt="$PDFLATEX_FORMAT_PATH$tag";  $resultFile = "$CACHE_PATH{$hash}_$mode.tex";  ASSERT_FILE ("$fmt.fmt"); 
      $template = "%&$fmt\n".PC_PDFLATEX_ADDON[$tag];  break;
    case "": 
      $resultFile = "$CACHE_PATH{$hash}$mode.tex";                                      // only in THIS case no underscore - above we NEED underscore
      $templateFileName = "$TEMPLATE_PATH$tag.tex";  ASSERT_FILE ($templateFileName);
      $template = file_get_contents ($templateFileName);
      break;
    default: 
      throw new Exception ("generateTex: received illegal mode $mode");
  }
  if (strpos ($template, MAGIC_LINE) == FALSE)   { throw new Exception ("generateTex: could not find MAGIC_LINE in template file " . $templateFileName); }  // check for MAGIC_LINE in template
  $markerStart = "\\typeout{" . ERROR_PARSER_START . "}";  // form a marker which helps the error parser in the log file detect the beginning of the document
  $markerEnd   = "\\typeout{" . ERROR_PARSER_END   . "}";  // form a marker which helps the error parser in the log file detect the beginning of the document
  $text = str_replace ( MAGIC_LINE, $markerStart.$rawContent.$markerEnd, $template);     // replace the MAGIC_LINE by the current input
  
  if($fileObject = fopen( $resultFile, 'w')) {fwrite($fileObject, $text);  fclose($fileObject);}
  else { throw new Exception ("generateTex: error writing result file $resultFile " ); }
  return $hash;
}


/** GENERATE PNG from DVI via DVIPNG tool
 *  assume there is a $hash.dvi file, generate a $hash$final.png file from it using the dvipng driver
 *    $hash    
 *    $dpi     dpi value to be used
 *    $gamma   gamma value to be used
 *    $final   part of the result file name, use to distinguish different runs with different parameters etc.
 */
private static function Dvi2Png ($hash, $dpi, $gamma=1.5, $inFinal="", $outFinal="") {
  $VERBOSE = true;  $CACHE_PATH = CACHE_PATH;
  ASSERT_FILE ("$CACHE_PATH$hash$inFinal.dvi");
  $cmd = DVIPNG_BINARY . " -T tight -p=1 -l=1 -D $dpi -gamma $gamma -o $CACHE_PATH$hash$outFinal.png  $CACHE_PATH$hash$inFinal.dvi ";    
  if ($VERBOSE) {$startTime = microtime(true);  self::debugLog ("Dvi2Png started for $hash, command is: " . $cmd . "\n");}
  // $output = null;  $retVal = null;  // do not need error messaging here
  exec ( $cmd );  
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed Dvi2Png. DURATION: " . $duration . "\n"); }   
}

/** GENERATE PNG from PDF via mutool. Transforms $hash.pdf into $hash$final.png
 */
private static function Pdf2PngMT ($hash, $dpi, $inFinal, $outFinal) {
  $VERBOSE = true;  $CACHE_PATH = CACHE_PATH;
  $cmd = MUTOOL. " convert -O resolution=$dpi -o $CACHE_PATH$hash$outFinal.png $CACHE_PATH$hash$inFinal.pdf  1-1";     // 1-1 is the page range    
  if ($VERBOSE) {$startTime = microtime(true);  self::debugLog ("Pdf2PngMT started for $hash, command is: " . $cmd . "\n");}
  // $output = null;  $retVal = null;  //  exec ( $cmd, $output, $retVal );  
  exec ( $cmd );  
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed Pdf2PngMT. DURATION: " . $duration . "\n"); }  
  // if ($VERBOSE) {self::debugLog ("  return value $retVal  output ". print_r ($output, true));} 
}


/** GENERATE PNG from PDF via mutool. Transforms $hash$inFinal.pdf into $hash$inFinal.png
 */
private static function Pdf2PngHtmlMT ($hash, $scale, $inFinal, $outFinal) {
  $VERBOSE = true; $JS_PATH = JS_PATH;  $CACHE_PATH = CACHE_PATH;
  $cmd = MUTOOL. " run  $JS_PATH/my-device.js $scale $CACHE_PATH$hash$inFinal $CACHE_PATH$hash$outFinal";       
  if ($VERBOSE) {$startTime = microtime(true);  self::debugLog ("Pdf2PngHtmlMT started for $hash, command is: " . $cmd . "\n");}
  $output = null;  $retVal = null;  
  exec ( $cmd, $output, $retVal );  
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed Pdf2PngHtmlMT. DURATION: " . $duration . "\n"); }  
}







private static function manuBoth ( $hash1, $inFinal1, $note1, $hash2, $scale2, $inFinal2, $outFinal2) {
  $VERBOSE = true;  $CACHE_PATH = CACHE_PATH;  $JS_PATH = JS_PATH;  
  ASSERT_FILE ("$CACHE_PATH$hash1$inFinal1.tex"); 
  // if ($VERBOSE) {self::debugLog ("Tex2Pdf sees the following environment: \n".print_r (getenv(), true) );}  // uncomment to check the active environment
  $cmd1 = PREFIX_ERROR . " pdflatex  --interaction=nonstopmode  -file-line-error-style -output-directory=$CACHE_PATH $CACHE_PATH$hash1$inFinal1.tex  >/dev/null 2>&1  "; 
  $cmd2 = MUTOOL. " run  $JS_PATH/my-device.js $scale2 $CACHE_PATH$hash2$inFinal2 $CACHE_PATH$hash2$outFinal2 >/dev/null 2>&1 ";  
  $cmd = "{ " . $cmd1 . " ; " . $cmd2 . " ;} >/dev/null 2>&1 & " ;
 
  $output = null;  $retval = null;   
  $res = exec ( $cmd, $output, $retval );    
 // if ($VERBOSE) { $endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed manuBoth ($note1). DURATION: $duration RETURN: $retval \n"); }   

//  file_put_contents ( $CACHE_PATH . $hash. "$inFinal.mrk", ( $retval != 0 ? "ERROR" : "" ) ); // write ERROR into .mrk file if there is an error to know about this later when we only access file system
  if (! file_exists ( "$CACHE_PATH$hash2$inFinal2.pdf") )  {
    throw new Exception ("Tex2Pdf: Did not generate $CACHE_PATH$hash2$inFinal2.pdf for this content. Probably TeX error or transient problem while editing.");} 
//  return ($retval == 0 ? 0 : $output);  
}





/** GENERATE SVG from PDF via mutool. Transforms $hash.pdf into $hash$final.png
 */
private static function Pdf2SvgMT ($hash, $dpi, $final="_mt", $inFinal="_pdflatex") {
  $VERBOSE = true;
  $CACHE_PATH = CACHE_PATH;
  $cmd = MUTOOL. " convert -O resolution=$dpi -o $CACHE_PATH$hash$final.svg $CACHE_PATH$hash$inFinal.pdf  1-1";     // 1-1 is the page range    
  if ($VERBOSE) {$startTime = microtime(true);  self::debugLog ("Pdf2SvgMT started for $hash, command is: " . $cmd . "\n");}
  // $output = null;  $retVal = null;  //  exec ( $cmd, $output, $retVal );  
  exec ( $cmd );  
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed Pdf2SvgMT. DURATION: " . $duration . "\n"); }  
  // if ($VERBOSE) {self::debugLog ("  return value $retVal  output ". print_r ($output, true));} 
}





/** GENERATE PNG from PDF via GHOSTSCRIPT
 *   devices:   pngmono   pngray  png256    png16
 */
 private static function Pdf2PngGS ($hash, $dpi, $final="_gs", $device="pngmono", $inFinal="_pdflatex") {
   $VERBOSE = true;
   $CACHE_PATH = CACHE_PATH;
   $cmd = GHOSTSCRIPT . "  -dSAFER -dBATCH -dNOPAUSE -sDEVICE=$device -r$dpi -sPageList=1 -o $CACHE_PATH$hash$final.png $CACHE_PATH$hash$inFinal.pdf  ";    
   if ($VERBOSE) {$startTime = microtime(true);  self::debugLog ("Pdf2PngGS started for $hash, command is: " . $cmd . "\n");}
   // $output = null;  $retVal = null;  // do not need error messaging here
   exec ( $cmd );  
   if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed Pdf2PngGS. DURATION: " . $duration . "\n"); }   
 }






// DEPRECATE
/** GENERATE DVI via LATEX
 *  Assume there is a $hash.tex file, generate a $hash.dvi file 
 *  We sometimes need different png resolutions from the save .tex file, so using just one tex to dvi run is better than merging this
 */
 /*
private static function generateDvi ($hash) {
  $VERBOSE = true;
  $CACHE_PATH = CACHE_PATH;
  $cmd = LATEX_COMMAND . " -output-dir=$CACHE_PATH $CACHE_PATH$hash.tex";              // MUST do a cd, since latex may generate some files in the local directory // TODO????????????????????????????? use build directoiry ???????
  if ($VERBOSE) {$startTime = microtime(true); self::debugLog ("generateDvi started for $hash, command is: $cmd \n");} 
  $output = null;  $retVal = null;
  exec ( $cmd, $output, $retVal ); 
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed generateDvi. DURATION: $duration \n"); }

  // we could have partially usable LaTeX output and still have errors. This can be seen in the exit code and is signaled in the .mrk file across different endpoint invocations
  file_put_contents ( $CACHE_PATH . $hash. ".mrk", ( $retVal != 0 ? "ERROR" : "" ) );
  if (! file_exists ( "$CACHE_PATH$hash.tex") )  {throw new Exception ("Could not generate ANY DVI for this content. Probably TeX error or transient problem while editing.");} 
}
*/

/** Generate dvi from tex using latex processor (works for ANY tex file, independently of precompilation settings) */

private static function Tex2DviLatex ($hash, $inFinal="") {
  $VERBOSE = true;
  $CACHE_PATH = CACHE_PATH;
  ASSERT_FILE ("$CACHE_PATH$hash$inFinal.tex");
  $cmd = LATEX_COMMAND . " -output-dir=$CACHE_PATH $CACHE_PATH$hash$inFinal.tex";              // MUST do a cd, since latex may generate some files in the local directory // TODO????????????????????????????? use build directoiry ???????
  if ($VERBOSE) {$startTime = microtime(true); self::debugLog ("Tex2DviLatex ($inFinal) for $hash$inFinal.tex, command is: $cmd \n");} 
  $output = null;  $retVal = null;
  exec ( $cmd, $output, $retVal ); 
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed Tex2DviLatex $inFinal for $hash$inFinal.tex. DURATION: $duration \n"); }

  // we could have partially usable LaTeX output and still have errors. This can be seen in the exit code and is signaled in the .mrk file across different endpoint invocations
  file_put_contents ( $CACHE_PATH . $hash. "$inFinal.mrk", ( $retVal != 0 ? "ERROR" : "" ) );
  if (! file_exists ( "$CACHE_PATH$hash$inFinal.dvi") )  {throw new Exception ("Tex2DviLatex: $inFinal Could not generate ANY DVI for this content. Probably TeX error or transient problem while editing.");} 
}

// CAVE: BUGS
/** Generate dvi from tex using pdflatex processor (works for ANY tex file, independently of precompilation settings) */
/** CAVE: It does not work to use pdflatex in dvi mode with a format which has been precompiled for pdf mode */
private static function Tex2DviPdflatex ($hash, $inFinal="") {
  $VERBOSE = true;
  $CACHE_PATH = CACHE_PATH;
  $cmd = PDFLATEX_COMMAND . " -output-format=dvi -output-dir=$CACHE_PATH $CACHE_PATH$hash$inFinal.tex";              // MUST do a cd, since latex may generate some files in the local directory // TODO????????????????????????????? use build directoiry ???????
  if ($VERBOSE) {$startTime = microtime(true); self::debugLog ("Tex2DviPdflatex command is: $cmd \n");} 
  $output = null;  $retVal = null;
  exec ( $cmd, $output, $retVal ); 
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed Tex2DviPdflatex for $hash$inFinal.tex. DURATION: $duration \n"); }

  // we could have partially usable LaTeX output and still have errors. This can be seen in the exit code and is signaled in the .mrk file across different endpoint invocations
  file_put_contents ( $CACHE_PATH . $hash. "$inFinal.mrk", ( $retVal != 0 ? "ERROR" : "" ) );
  if (! file_exists ( "$CACHE_PATH$hash$inFinal.dvi") )  {throw new Exception ("Tex2DviPdflatex: Did not generate $CACHE_PATH$hash$inFinal.dvi for this content. Probably TeX error or transient problem while editing.");} 
}



private static function Tex2Pdf ($hash, $inFinal, $note) {
  $VERBOSE = true;  $CACHE_PATH = CACHE_PATH;
  ASSERT_FILE ("$CACHE_PATH$hash$inFinal.tex"); 
  // if ($VERBOSE) {self::debugLog ("Tex2Pdf sees the following environment: \n".print_r (getenv(), true) );}  // uncomment to check the active environment
  $cmd = PREFIX_ERROR . " pdflatex  --interaction=nonstopmode  -file-line-error-style -output-directory=$CACHE_PATH $CACHE_PATH$hash$inFinal.tex"; 
  if ($VERBOSE) { $startTime = microtime(true); self::debugLog ("Tex2Pdf started ($note) for $hash$inFinal, command is: $cmd \n");}   
  $output = null;  $retval = null;   
  $res = exec ( $cmd, $output, $retval );    
  if ($VERBOSE) { $endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed Tex2Pdf ($note) for $hash$inFinal. DURATION: $duration RETURN: $retval \n"); }   
  file_put_contents ( $CACHE_PATH . $hash. "$inFinal.mrk", ( $retval != 0 ? "ERROR" : "" ) ); // write ERROR into .mrk file if there is an error to know about this later when we only access file system
  if (! file_exists ( "$CACHE_PATH$hash$inFinal.pdf") )  {
    throw new Exception ("Tex2Pdf: Did not generate $CACHE_PATH$hash$inFinal.pdf for this content. Probably TeX error or transient problem while editing.");} 
  return ($retval == 0 ? 0 : $output);
}




/** GENERATE HTML from PDF with annotations using NODE-tool
 *  assume the existence of file   $hash.pdf    TODO: or different ??????
 *  return html text of annotation layer
 *  if $saveFile = true also save it as file $hash.html
 *
 */
static function generateHTML ($hash, $htmlScale =1, $horizontalDelta=0, $verticalDelta=0, $saveFile=true ) {
  $VERBOSE = true;  $CACHE_PATH = CACHE_PATH;  $PDF2HTML = PDF2HTML;
  $cmd = "$PDF2HTML $CACHE_PATH$hash_pdflatex.pdf  $CACHE_PATH$hash.html  $htmlScale  $horizontalDelta  $verticalDelta  >$CACHE_PATH$nameBase._html.stdout 2>$CACHE_PATH$nameBase._html.stderr";  
  if ($VERBOSE) {$startTime = microtime(true); self::debugLog ("generateHTML started for $hash, command is: $cmd \n");}     
  $output = null;  $retVal = null;
  exec ( $cmd, $output, $retVal ); 
  if (VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed generateHTML. DURATION: $duration \n"); }
  if ($saveFile) {file_put_contents ( "$CACHE_PATH$hash.html", $output );}
  return $output;
}



/** GENERATE PDF via PDFLATEX  from  $hash.tex => $hash.pdf
 *  Assume there is a $has.tex file, generate a $hash_pdflatex.pdf file using pdflatex
 *  Used jobname is $hash_pdflatex in order to have all intermediary files (such as .aux, .log) seperate from other tex engines which might be in use as well
 *  returns exit value
 */
static function generatePDF ($hash) {
  $VERBOSE = true;
  $CACHE_PATH = CACHE_PATH;
  ASSERT_FILE ("$CACHE_PATH$hash.tex"); 
  $cmd = PDFLATEX_COMMAND ." -output-directory=$CACHE_PATH $CACHE_PATH$hash.tex ";  
  if ($VERBOSE) { $startTime = microtime(true); self::debugLog ("generatePDF started for $hash, command is: $cmd \n");}   
  $output = null;  $retVal = null;   
  $res = exec ( $cmd, $output, $retval );    
  if ($VERBOSE) {  $endTime = microtime (true); $duration = $endTime - $startTime; self::debugLog ("  completed generatePDF. DURATION: $duration \n"); }         
  return $retVal;
}

/** generate bounding box information from pdfFileName
 *  construct the filename from the $hash and an additional qualifier for the pdf as in  $hash$inFinal.pdf
 *    $hashFinal is $hash, possibly with a precompilation tag, uniquely defining the $hashFinal.pdf file we need here
 */
static function generatePdfBboxGS ($hashFinal) {
  $VERBOSE = true;
  $GHOSTSCRIPT = GHOSTSCRIPT;
  $CACHE_PATH = CACHE_PATH;
  ASSERT_FILE ("$CACHE_PATH$hashFinal.pdf");
  $cmd = "$GHOSTSCRIPT -dBATCH -dNOPAUSE -dQUIET -sPageList=1 $CACHE_PATH$hashFinal.pdf 2>&1";  // need the stderr to stdout redirect since ghostscript outputs this on stderr
  if ($VERBOSE) {$startTime = microtime(true); self::debugLog ("generatePdfBboxGS started for $hashFinal, command is: $cmd \n");}  
  $output = null; $retVal = null;
  $res = exec ($cmd, $output, $retval);  // output should now be an array, one item per line and we should get two elements, the normal and the hi res bounding box  
                                         // if we get more there is either an error or we have a multi-page pdf  the first is the normal bounding box and it has string format as in:  %%BoundingBox: 0 0 426 823
  if ($VERBOSE) { self::debugLog ("  output obtained from ghostscript is:" . print_r($output, true) . "\n");}
  $txtArray = explode (" ",$output[0]);
  
  if ( !str_starts_with ($txtArray[0], "%%BoundingBox") ) { throw new ErrorException ("generatePdfBboxGS: could not find ghostscript bounding box answer for $hashFinal. Output obtained was ".print_r($output, true)); }
  
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime; $outputTxt =  "1=".$txtArray[1]." 2=".$txtArray[2]."".$txtArray[3]."".$txtArray[4]; self::debugLog ("  completed generatePdfBboxGS for $hashFinal. DURATION: $duration  returned $retval RESULT: $outputTxt \n");}  
  $result = array ( "left" => $txtArray[1], "top" => $txtArray[2], "left" => $txtArray[3], "left" => $txtArray[4]);
  return $result; 
}


/** get a width, height array for the Png file generated from the latex-dvi-dvipng path 
 *  assuming that the $hash.tex, $hash.dvi and $hash.png already exist or get 0 if file does not exist
 */
static function getSizeFromDviPng ($hash) {
  $CACHE_PATH = CACHE_PATH;
  $path = $CACHE_PATH.$hash.".png";  
  if (file_exists ($path))  {$ims = getimagesize ( $path ); $ims["width"] = $ims[0]; $ims["height"] = $ims[1];} else { $ims = 0;}  
  return 0;
}

/** assume the existence of $hash_pdflatex.pdf, produce a png, use it for cropping and produce an adjusted html
*/
static function generateNodePngHtml ($hash, $scale=2.54) {
  $VERBOSE = true;
  $CACHE_PATH = CACHE_PATH;
  $htmlScale = $pngScale = $scale;
  $cmd = NODE_BINARY . " " . NODE_SCRIPT. " " .  $CACHE_PATH . $hash. "_pdflatex.pdf " . $CACHE_PATH . $hash. "_node.png " . $CACHE_PATH . $hash. ".html " .  $pngScale . " " . $htmlScale  ." >". $CACHE_PATH . $hash."_node.stdout 2>" . $CACHE_PATH . $hash."_node.stderr";  
  if ($VERBOSE) {$startTime = microtime(true); self::debugLog ("generateNodePngHtml started for $hash, command is: $cmd \n");}  
  $output = null;  $retVal = null;  
  $res = exec ( $cmd, $output, $retval );
  if ($VERBOSE) {$endTime = microtime (true); $duration = $endTime - $startTime;  self::debugLog ("  completed generateNodePngHtml - DURATION: " . $duration . "  retval=".$retval."  res=".$res." \n"); }    
}



/////// TODO: there still is a permission problem with this thing here 
/*
static function completeInBackground ($hash) {
  $CACHE_PATH = CACHE_PATH;
  //////// TODO: ADJUST and improve these settings !
  $pngScale = "2.54";    // if   "0"  we produce no png
  $htmlScale = "2.54";   // if  "0"  produce no html
  
  // NOTE: The reason that we do this so complicated is that we need a particular sequence of jobs to run in the background of php. 
  // We never got that running in *all* details, especially setting particular paths and shell variables for pdflatex and getting proper redirects and debug info

  $sheBang = "#!/bin/sh";
  $cd = "cd ".CACHE_PATH;
  $cmdPdflatex =  PDFLATEX_COMMAND . " -jobname " . $hash . "_pdflatex " .  $CACHE_PATH . $hash . ".tex " . ">".$CACHE_PATH.$hash."_pout  2>".$CACHE_PATH. $hash. "_perr";
  $cmdNode = NODE_BINARY . " " . NODE_SCRIPT. " " .  $CACHE_PATH . $hash . "_pdflatex.pdf " . $CACHE_PATH . $hash . "_node.png " . $CACHE_PATH . $hash . ".html " .  $pngScale . " " . $htmlScale  ." >". $CACHE_PATH . $hash."_nout 2>" . $CACHE_PATH . $hash."_nerr";  

  $shellFileName = $CACHE_PATH . $hash . ".sh";
  touch ($shellFileName);
  chmod ( $shellFileName, 0774);  
  if($shellFile = fopen( $shellFileName, 'w')) {
    fwrite($shellFile, $cd."\n".$sheBang."\n".$cmdPdflatex."\n".$cmdNode);  
    fclose($shellFile);
  } 
  exec ($shellFileName . " >/dev/null 2>/dev/null & ");    // kickoff and run in background.  ///// TODO: we do not want to keep output and stderr here ????
                                                           // MUST have a redirect of the stdout and stderr or we will block/https://stackoverflow.com/questions/14555971/php-exec-background-process-issues
}
*/










} // END of class





?>
